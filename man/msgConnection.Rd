% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conn.R
\name{msgConnection}
\alias{msgConnection}
\alias{partial}
\alias{partial.msgConnection}
\alias{readMsgs}
\alias{status}
\alias{status.msgConnection}
\alias{readMsg}
\alias{writeMsg}
\alias{writeMsgs}
\title{Read and write msgpack messages using a connection.}
\usage{
msgConnection(conn, read_size = 2^16, max_size = NA, ...)

partial(conn)

\method{partial}{msgConnection}(conn)

readMsgs(conn, n = NA, ...)

status(conn)

\method{status}{msgConnection}(conn)

readMsg(conn, ...)

writeMsg(obj, conn, ...)

writeMsgs(objs, conn, ...)
}
\arguments{
\item{conn}{A \link{connection} object open in binary mode.}

\item{read_size}{How many bytes to read at a time.}

\item{max_size}{The largest partial uncompleted message to
store. \code{NA} means do not enforce a limit.}

\item{...}{Unpacking options (see \link{unpackMsg}).}

\item{n}{The maximum number of messages to read. A value of NA
means to parse all available messages up until the end of input.}

\item{obj}{An R object.}

\item{objs}{A list of R objects.}
}
\value{
\code{\link[=msgConnection]{msgConnection()}} returns an object of class 'msgConnection'

Because msgpack messages have unpredictable length, the decoder
reads ahead in chunks, then finds the boundaries between messages.
Therefore when reading over a socket or a fifo it is best to use a
nonblocking connection, and it will not work to mix readMsg and
readBin on the same connection.

In the present implementation, decoding must start over at the
beginning of the message when it is split across two or more
chunks. So \code{read_size} should be set to something larger than the
typical message recieved.

If you are reading data from an untrusted source you will probably want
to set option \code{max_size} (see \link{unpackOpts}).  This
protects against stack overflows and out-of-memory errors that
could be caused by some messages.

Reading from connections is somewhat experimental at the
moment. Please report problems you encounter.

\code{readMsgs(conn, n)} returns a list of some length between 0
and n, containing the decoded messages.

\code{status(conn)} returns the status of msgpack decoding on the
connection. A value of \code{"ok"} indicates all requested messages
were read, \code{"buffer underflow"} indicates a partial message is on
the line, \code{"end of input"} means the last available message has
been read.  Other values indicate errors encountered in decoding,
which will effectively halt reading.

\code{readMsg(conn)} returns exactly one message, or throws an error.
}
\description{
Read and write msgpack messages using a connection.

\code{writeMsgs(l, conn)} writes a list of
messages to a connection. That is, \code{writeMsg(1:10, conn)} writes one
message containing an array, while \code{writeMsgs(1:10, conn)} writes
ten consecutive messages each containing one integer.
}
\examples{
out <- rawConnection(raw(0), open="wb")
apply(quakes, 1, function(x) writeMsg(x, out))
length(rawConnectionValue(out))
inn <- msgConnection(rawConnection(rawConnectionValue(out), open="rb"))
readMsg(inn)
readMsgs(inn, 3)
}
