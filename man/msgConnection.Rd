% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conn.R
\name{msgConnection}
\alias{msgConnection}
\alias{close.msgConnection}
\alias{partial}
\alias{partial.msgConnection}
\alias{readMsgs}
\alias{status}
\alias{status.msgConnection}
\alias{seek.msgConnection}
\alias{readMsg}
\alias{writeMsg}
\alias{writeMsgs}
\title{Read and write msgpack messages using a connection.}
\usage{
msgConnection(con, read_size = 2^16, max_size = NA, ...)

\method{close}{msgConnection}(con, ...)

partial(conn)

\method{partial}{msgConnection}(conn)

readMsgs(conn, n = NA, ...)

status(conn)

\method{status}{msgConnection}(conn)

\method{seek}{msgConnection}(con, where = NA, origin = "start",
  rw = summary(con)$mode)

readMsg(con, ...)

writeMsg(obj, con, ...)

writeMsgs(objs, con, ...)
}
\arguments{
\item{read_size}{How many bytes to read at a time.}

\item{max_size}{The largest partial uncompleted message to
store. \code{NA} means do not enforce a limit.}

\item{...}{Unpacking options (see \link{unpackMsg}).}

\item{conn}{A \link{connection} object open in binary mode.}

\item{n}{The maximum number of messages to read. A value of NA
means to parse all available messages until end of input.}

\item{objs}{A list of R objects.}
}
\value{
\code{\link[=msgConnection]{msgConnection()}} returns an object of class 'msgConnection'

Because msgpack messages have unpredictable length, the decoder
reads ahead in chunks, then finds the boundaries between messages.
Therefore when reading over a socket or a fifo it is best to use a
nonblocking connection, and it will not work to mix readMsg and
readBin on the same connection.

If you are reading data from a not completely trusted source you
will probably want to give options \code{max_size} and \code{max_depth} (see
\link{unpackOpts}). Without it, some deeply nested or cleverly designed
messages can cause a stack overflow or out-of-memory error.  With
these options set, you will get an R exception instead.

A list of up to \code{n} decoded messages.

\code{status(conn)} returns the status of msgpack decoding on the
connection. A value of \code{"ok"} indicates all requested messages
were read, \code{"buffer underflow"} indicates a partial message is on
the line, \code{"end of input"} means the last available message has
been read.  Other values indicate errors encountered in decoding,
which will effectively halt reading.

\code{readMsg(conn)} returns exactly one message, or throws an error.
}
\description{
Read and write msgpack messages using a connection.

...

\code{seek(con)} returns the number of bytes that have been successfully
read or written.

...

...

\code{writeMsgs(l, conn)} writes a list of
messages to a connection. That is, \code{writeMsg(1:10, conn)} writes one
message containing an array, while \code{writeMsgs(1:10, conn)} writes
ten consecutive messages each containing one integer.
}
\examples{
out <- rawConnection(raw(0), open="wb")
apply(quakes, 1, function(x) writeMsg(x, out))
length(rawConnectionValue(out))
inn <- msgConnection(rawConnection(rawConnectionValue(out), open="rb"))
readMsg(inn)
readMsgs(inn, 3)
}
