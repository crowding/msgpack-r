% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unpack.R
\name{unpackb}
\alias{unpackb}
\title{Unpack a raw byte object in msgpack format into an R data object.}
\usage{
unpackb(x)
}
\arguments{
\item{dat}{\code{\link[base:raw]{base::raw()}} byte data.}

\item{use_envs}{if FALSE, msgpack dicts are unpacked into a vector
or list with a name attribute. If true, msgpack dicts are
unpacked into environment objects.}

\item{simplify}{If \code{FALSE}, msgpack arrays will be unpacked
into lists. If \code{TRUE}, will produce atomic vectors when possible.}

\item{transform}{A function will be called for each data element.}

\item{dict}{What type of object to produce given a msgpack dict. If given an env, will encode as an env with that as parent. If given a vector, will}
}
\value{
an R data object.

The msgpack format does not have typed arrays, so all msgpack
arrays are effectively lists from the R perspective. However, if an
array containing compatibly typed elements is read, \code{unpack} will
return a logical, integer, real or string vector as
appropriate. Integer values may be converted to real, but boolean
values will not be cast to numeric, not any types to string. If
conversion from a large integer to real loses precision, a warning
is produced. If option \code{simplify} is FALSE, msgpack arrays will
always be turned into R lists.

Because msgpack does not distinguish NA and NULL, nil values in a
msgpack will be decoded as NA when producing a vector, and NULL
when returning a list.
}
\description{
Unpack a raw byte object in msgpack format into an R data object.
}
